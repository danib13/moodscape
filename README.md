# MOODScapes
#### Video Demo:  https://youtu.be/nhRn8Fr7mFk
#### Description: Web application that generates song recommendations based on weather for each user.
## Abstract
Moodscapes is a web application that gives users song recommendations based on the weather. This is generated by utilizing a combination of Google, Pirate Weather, and Spotify APIs. However, if the user is up for anything in general, there is also a section for randomly generated song recommendations. The recommendations created for a particular user are saved and visible in their user history.
## Code
### app.py
This project was built upon the bare bones of Finance, a previous web project. The user /login, /register, and /logout are reused from the previous project, as well as the addition of /settings where a user can change their password.

There are new routes: /start, /rand, /history. Another new addition is the implementation of APIs, in the beginning of app.py it starts by checking that the needed keys and client info have been provided.
#### Routes
##### "/settings"
This page allows the user to update their password. It also makes sure the user is logged in, and then asks for the username, current password, and new password. It then updates the database mood.db table "users" where the username and id match the current account. If the old password, or the username is incorrect, it will fail and give an apology stating the error message.
##### "/start"
This page is where users can input either the city or the weather that they are exposed to and submit it to the system so that they can later receive recommendations. If both city and weather are given, then the system will prioritize the city name to get the needed information. This information is then used to call upon the APIs to generate songs. First, given a city name, it will call upon ```getCityLatLong(cityName)``` that is a helper function for calling upon Google API to get the latitude and longitude coordinates. Those coordinates are then used to call upon ```lookup(lat,lon)``` helper function for Pirate Weather API to get the current weather in the city. The weather is then cross referenced with **weather_genre** table from mood.db, this is a table that has various genres that correspond to a type of weather pattern. Once a genre is found, Spotify API is setup using ```setup_spotify()``` and then the genre will be sent to Spotify in order to retrieve a list of relevant songs and their information. Once a list of recommendations is generated, if the song is not already in the database, it will be logged into the table **song_info**. Additionally, each recommended song will be added to the user's history in the database under **user_song_history** with their account's **user_id** and **song_id** for that particular song. Then, the song list will be sorted by title, and available to be viewed by the results page since the list, as well as the weather, will be passed to the results.html template.
##### "/rand"
This page will generate music recomendations by randomly selecting a weather type (unseen to the user), and then following the same process of calling upon APIs. The weather is then cross referenced with **weather_genre** table from mood.db, this is a table that has various genres that correspond to a type of weather pattern. Each available genre for this weather will be used, and two songs will be selected for each genre. Once a genre is found, Spotify API is setup using ```setup_spotify()``` and then the genre will be sent to Spotify in order to retrieve a list of relevant songs and their information. Once a list of recommendations is generated, if the song is not already in the database, it will be logged into the table **song_info**. Then, the song list will be sorted by title, and available to be viewed on the random.html template.
##### "/history"
Here is where the user's history is gathered from all their past recommendations. Randomized recommendations made from "/rand" will not appear. The user history is gathered from the **mood.db** tables by selecting the unique entries that correspond to their user id. Since the **user_song_history** table only has id information, it is joined with the **song_info** table in order to map the song_id to the necessary info such as song title and artist. This history is passed to and made viewable on the history.html template.
```
history = db.execute("SELECT DISTINCT * FROM song_info JOIN user_song_history ON song_info.id = user_song_history.song_id WHERE (user_id=?) ORDER BY title",user_id)
```
### helpers.py
Within helpers.py is where all the APIs will be used, as well as other helper functions that will be called in app.py.
#### apology(message, code=400)
Handles apology messages for when there is an error. Such instances would be: username or password are incorrect.
#### login_required(f)
Login_required helps us take care of checking whether a user is logged in. If login_required finds that user_id is None, it will redirect to login.

#### getCityLatLon(cityName)
Using the input cityname from the start page, this function finds the corresponding latitude and longitude coordinates. To do so, it contacts the Google API given that the Google API key is set up and valid. Through a request and response, a result will be parsed. Since we are only interested in the location, the only relevant information we need is from that key.
```
result = response.json()
location = result['results'][0]['geometry']['location']
```

Location provides us with a dictionary that includes both latitude and longitude values. It returns the results in the form of:
```
{
        "latitude": latitude,
        "longitude": longitude
}
```

#### lookup(latitude, longitude)
This is a function that takes two floats that stand for the latiude and longitude. Given these parameters, and assuming an API key for Pirate Weather has been setup, the API will be contacted. Through a request and response, a result will be parsed. The result is a multilevel dictionary. This result is then used to create a new dictionary only with the variables we are interested in: "temp", "temp_min", "temp_max", and "icon". This is returned to app.py to be used when the current weather is needed.
```
{
    "temp": result["currently"]["temperature"],
    "tempMin": int(result["daily"]["data"][0]["temperatureLow"]),
    "tempMax": result["daily"]["data"][0]["temperatureHigh"],
    "icon": result["currently"]["icon"]
}
```
#### setup_spotify()
This function certifies that the Spotify API is set up properly with the correct and valid CLIENT_SECRET and CLIENT_ID. By sending this information through a post request to Spotify, a response will give the needed access_token to use the API.
#### get_song(genre, access_token, count)
Using the **access_token** retrieved from setup_spotify() as the API key, Spotify can now be utilized to generate songs. A search can be requested by using **genre** as a parameter to find tracks. The resulting response can be parsed to find the track information.
```
tracks = response.json()['tracks']['items']
```
The **count** will determine how many of the search results we want to use. A user will not want all the Pop songs, but maybe just the first few. Each track is appended into a list ```songs = []``` where only the information relevant to the application is saved. Each track is appended until **count** number of tracks are in **songs**. Then the list **songs** is returned.
```
songs.append({"title": track["name"], "artist": track["artists"][0]["name"], "genre": genre, "uri": track['uri'], "image": track['album']['images'][0]})
```
#### response.txt
This file includes the json response of one track that was tested. It shows the information that is made available by using Spotify's API. This is how the album artwork, song title, and artist name are gathered.

### Mood.db
In order to view the database, in the terminal:
1. Go to the project folder
```
cd project
```
2. Run the command
```
sqlite3 mood.db
```
3. Find schema
```
.schema
```
4. View tables
```
SELECT * FROM [table name];
```
5. Return to project
```
.exit
```

The following three SQL objects are used in order to create and keep track of each user's account.
```
CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, username TEXT NOT NULL, hash TEXT NOT NULL);
CREATE TABLE sqlite_sequence(name,seq);
CREATE UNIQUE INDEX username ON users (username);
```
Song_info is the table where all the generated songs and their info are stored into a master table--each song is given a unique identifier so a song that is recommended multiple times does not have its info repeated.
```
CREATE TABLE song_info (id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, title TEXT NOT NULL, artist TEXT NOT NULL, genre TEXT NOT NULL);
CREATE UNIQUE INDEX idx_song_info ON song_info (title,artist);
```
Weather_genre is a table that maps each possible weather icon that is provided by Pirate Weather API to a variety of different genres that fit the mood of each possible weather type available.
```
CREATE TABLE weather_genre (weather TEXT NOT NULL, genre TEXT NOT NULL);
```
To keep track of each user's song recommendation history, their user id and the song's id are stored in a table called "user_song_history".
```
CREATE TABLE user_song_history (user_id INTEGER NOT NULL, song_id INTEGER NOT NULL);
```
In order to provide randomized recommendations, the weather is also saved with a weather id. This is so a random number generator can pick a weather type, and from there the system would use the same procedure to find some genres based on that weather.
```
CREATE TABLE weather_type (id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, weather TEXT NOT NULL);
```

## Design
### Styles.css
Since this application is a relaxing music recommendation system based on the weather, its style reflects that. The main color is a perriwinkle blue (#95B1F1), since blue is associated with peacefulness, calm, and the ocean or water. The analogous accent colors we have to work with are purples (#A795F1 and #D595F1), a cool toned pink (#F195DF), salmon (#F195B1), and a soft orange (#F1A795). These provide pops of color while being harmonious with the main color.
#### Table
To organize tables for the results, there is a "musicplayer" container class. This provides a format that creates a playlist view that the songs go into. Visually, rounded edges help give a feel as if it was similar to a music app.
#### Images
Images are given their own container, and are sized so that they match the size of the row. Each image is an album cover, these are only visible during song recommending. Each album cover is rounded so that it becomes cd-shaped.



### Templates
Each page has its own HTML template

#### apology.html
_As seen previously in Finance_

#### history.html
Shows user history for the currently logged-in user. Displays the list of songs with unique song ids--no repeated songs will show up.

#### index.html
This is the page a logged in user will see first. It gives a quick intro and a start button for the beginning of the process.

#### layout.html
Layout is not necessarily its own page but the base for other pages. It provides the base layout and toolbar for each page.

#### login.html
_As seen previously in Finance_

#### random.html
Page where user can see randomly generated song recommendations.

#### register.html
_As seen previously in Finance_

#### results.html
Results page with song recommendations if user was previously at Start page. Will also show the weather that was input, or weather currently from the city that was input.

#### settings.html
Page where a user can update their password.

#### start.html
From index, if the user chose to START, it will show the ability to either input a city, or a weather type and submit. This would then transfer them to Results.

## Run
1. Make sure you are in the Project folder
```
cd project
```
2. Pass API keys and credentials. _Without brackets._
```
export API_KEY_WEATHER=[API KEY]
```
```
export API_KEY_GOOGLE=[API KEY]
```
```
export SPOTIFY_CLIENT_ID=[insert ID here]
```
```
export SPOTIFY_CLIENT_SECRET=[insert code here]
```
3. Run
```
flask run
```
4. Open the url and use the website application.